# 架构

- 异步架构

  &nbsp;&nbsp;传统的Iaas采用同步架构，线程池为每个任务提供线程，线程只有在前一个任务完成之后才能为下一个任务服务。例如创建虚拟机，通常的执行路径为”identity service-->scheduler-->image service-->storage service-->network service-->hypervisor”，它的每一环节都要一定的耗时，大批量任务执行时，延迟效应就更明显，最后就可能出现任务失败。<br/>
  ZStack 99%的任务都是异步执行的，这是使它单个节点能够管理几十万的物理机、几百万的虚拟机和处理上万并发人物的关键。
  
  ZStack 的异步架构由三部分组成：异步消息、异步方法和异步HTTP调用。<br/>
  异步消息：<br/>
  ZStack 使用 RabbitMQ 作为连接各种服务的消息总线。当一个服务调用另一个服务的时候，源服务向目的服务发送一个消息同时注册回调函数，然后立即返回。当目的服务完成任务后，它响应触发源服务注册的回调函数来通知结果。<br/>
  异步方法：<br/>
  在ZStack 中，作为一等公民类型的服务通过异步消息进行交互。对于服务内部，一系列的互相关联的组件，插件是通过异步方法调用来交互的。<br/>
  异步 HTTP 调用：<br/>
  ZStack 使用几个代理来管理外部系统，例如 KVM 主机、控制台代理和虚拟路由等。它们都是以 Python CherryPy 为基础构建的轻量级 Web 服务。ZStack 可以进行双向通讯，它在每次请求的时候把回调 URL 放入 HTTP 头部，代理可以在任务完成的时候把响应发送给调用方的 URL。<br/>
  ![异步架构图](http://zstack.org/images/blogs/scalability/2.png)
--------
- 无状态服务

  当用户想要一个高可用的生产环境或者处理海量并发负载时，需要进行横向扩展，即增加节点，这时就需要一个可靠的分发系统。ZStack 构建了一个由无状态服务组成的无状态分发系统。
  
  什么是状态？当系统中存在多余一个服务实例的时候，资源会被划分为不同的实例。例如，假如有10,000个虚拟机和两个虚拟机服务实例，每个实例管理5000个虚拟机，像 ”哪个服务实例正在管理什么资源“ 的认知，正是我们正在谈论的状态。当服务实例的数目发生变化的时候，服务需要交换状态，这就成了系统可扩充性的瓶颈。有了无状态服务，请求方不再需要询问向哪里发送请求，当新的服务示例加入到旧的示例中时，服务不再需要交换状态。
  
  每个 ZStack 的服务都是无状态的。 ZStack 把所有的服务都封装进一个叫做管理节点的单一进程中，使得部署和管理服务极其简单。一个管理节点是一个完整功能的ZStack软件。由于包含了无状态服务，管理节点没有共享状态，但是有心跳记录，以及一致性哈希算法环（consistent hashing ring）。心跳用来监测管理节点的健康状况，一旦一个管理节点停止更新它的管理节点一段时间后，其他的管理节点就会将它删除并接管它管理的资源。
  
  具体到 ZStack 的业务逻辑，实现无状态服务的核心技术是[一致哈希算法](http://www.tom-e-white.com/2007/11/consistent-hashing.html)。当系统启动的时候，每个管理节点都会被分配一个用来配合服务名称在消息总线上注册一个服队列的版本4 UUID（Version 4 UUID）。资源，如主机，容量，虚拟机，也是通过UUID来标识的。消息，常常和资源相关联，是在服务间传递的。在发送消息之前，发送者必须选择基于资源的UUID的接收者服务。
  
  每个管理节点都维护一个系统所有包含 UUID 的所有管理节点的环的复制。当一个管理节点加入或离开时，生命周期事件将或通过消息总线向其他所有的节点广播，使其他节点扩展或者压缩他们的环以适应当前的系统状态。当发送的时候，发送者的服务方将会使用资源的 UUID 哈希出目的管理节点的 UUID。在一个稳定的环中，拥有相同 UUID 的资源时可以经常被路由到相同的服务，这是 ZStack 无锁架构的基础。由于一致哈希环的存在，发送方不必知道哪个服务实例将要处理这个消息，这个实例将会被哈希出来。服务不必维护和交换他们管理这的资源的信息，他们只需要处理接收到的消息，因为一致哈希环能够确保消息能够找到正确的服务实例。
  ![一致哈希环](http://zstack.org/images/blogs/scalability/stateless-service7.png)
